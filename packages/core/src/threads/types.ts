// ABOUTME: Type definitions for thread events and thread management
// ABOUTME: Events include user messages, agent messages, tool calls, and tool results

import type { ToolCall, ToolResult } from '~/tools/types';
import type { CompactionData } from '~/threads/compaction/types';
import type { ApprovalDecision } from '~/tools/approval-types';
import type { CombinedTokenUsage } from '~/token-management/types';
import type { Task, TaskContext } from '~/tasks/types';

// Single source of truth for all event types
export const EVENT_TYPES = [
  // Persisted events
  'USER_MESSAGE',
  'AGENT_MESSAGE',
  'TOOL_CALL',
  'TOOL_APPROVAL_REQUEST',
  'TOOL_APPROVAL_RESPONSE',
  'TOOL_RESULT',
  'LOCAL_SYSTEM_MESSAGE',
  'SYSTEM_PROMPT',
  'USER_SYSTEM_PROMPT',
  'COMPACTION',
  // Transient events (not persisted to database)
  'AGENT_TOKEN',
  'AGENT_STREAMING',
  'AGENT_STATE_CHANGE',
  'COMPACTION_START',
  'COMPACTION_COMPLETE',
  // Task events (transient)
  'TASK_CREATED',
  'TASK_UPDATED',
  'TASK_DELETED',
  'TASK_NOTE_ADDED',
  // Agent lifecycle events (transient)
  'AGENT_SPAWNED',
  'AGENT_SUMMARY_UPDATED',
  // Project events (transient)
  'PROJECT_CREATED',
  'PROJECT_UPDATED',
  'PROJECT_DELETED',
  // System events (transient)
  'SYSTEM_NOTIFICATION',
  // Error events (transient)
  'AGENT_ERROR',
] as const;

// Derive LaceEventType union from the array
export type LaceEventType = (typeof EVENT_TYPES)[number];

// Helper to check if an event type is transient (not persisted to database)
export function isTransientEventType(type: LaceEventType): boolean {
  // These event types are always transient, even if they have a threadId
  return [
    'AGENT_TOKEN',
    'AGENT_STREAMING',
    'AGENT_STATE_CHANGE',
    'COMPACTION_START',
    'COMPACTION_COMPLETE',
    // Task events
    'TASK_CREATED',
    'TASK_UPDATED',
    'TASK_DELETED',
    'TASK_NOTE_ADDED',
    // Agent lifecycle events
    'AGENT_SPAWNED',
    'AGENT_SUMMARY_UPDATED',
    // Project events
    'PROJECT_CREATED',
    'PROJECT_UPDATED',
    'PROJECT_DELETED',
    // System events
    'SYSTEM_NOTIFICATION',
    // Error events
    'AGENT_ERROR',
  ].includes(type);
}

/**
 * Event Category Helpers
 *
 * Lace events fall into three semantic categories:
 *
 * 1. CONVERSATION EVENTS: Persisted and shown in timeline
 *    - USER_MESSAGE, AGENT_MESSAGE, TOOL_CALL, TOOL_RESULT, etc.
 *    - These form the core conversation history
 *
 * 2. TRANSIENT EVENTS: Not persisted, used for real-time updates
 *    - AGENT_TOKEN, AGENT_STREAMING, AGENT_STATE_CHANGE, etc.
 *    - These provide live feedback but aren't part of history
 *
 * 3. INTERNAL WORKFLOW EVENTS: Persisted but not shown in timeline
 *    - TOOL_APPROVAL_REQUEST, TOOL_APPROVAL_RESPONSE
 *    - These support features like resumable approvals after restart
 */

/**
 * Check if an event is part of internal workflow (persisted but not shown)
 * These events are persisted for system functionality but hidden from users
 */
export function isInternalWorkflowEvent(type: LaceEventType): boolean {
  return ['TOOL_APPROVAL_REQUEST', 'TOOL_APPROVAL_RESPONSE'].includes(type);
}

/**
 * Check if an event should be shown in the conversation timeline
 * These are the events that form the visible conversation history
 */
export function isConversationEvent(type: LaceEventType): boolean {
  // Conversation events are those that are:
  // 1. Not transient (persisted to database)
  // 2. Not internal workflow events (hidden from timeline)
  return !isTransientEventType(type) && !isInternalWorkflowEvent(type);
}

// Tool approval event data types
export interface ToolApprovalRequestData {
  toolCallId: string;
}

export interface ToolApprovalResponseData {
  toolCallId: string;
  decision: ApprovalDecision;
}

// Base interface for common properties
interface BaseLaceEvent {
  id?: string; // Optional - generated by ThreadManager if not provided
  threadId: string;
  timestamp?: Date; // Optional - generated by ThreadManager if not provided
  // New fields for unified event system
  transient?: boolean; // If true, don't persist to database
  context?: {
    sessionId?: string;
    projectId?: string;
    taskId?: string;
    agentId?: string;
  };
}

// Agent message data with optional token usage
export interface AgentMessageData {
  content: string;
  tokenUsage?: CombinedTokenUsage;
}

// Data types for transient events
interface AgentTokenData {
  token: string;
}

interface AgentStreamingData {
  content: string;
}

export interface AgentStateChangeData {
  agentId: ThreadId;
  from: string;
  to: string;
}

interface CompactionStartData {
  auto: boolean;
}

interface CompactionCompleteData {
  success: boolean;
  error?: string;
  summary?: string;
  originalEventCount?: number;
  compactedEventCount?: number;
}

// Task event data types
interface TaskCreatedData {
  taskId: string;
  task: Task;
  context: TaskContext;
  timestamp: Date;
  type: 'task:created'; // For compatibility with existing handlers
}

interface TaskUpdatedData {
  taskId: string;
  task: Task;
  context: TaskContext;
  timestamp: Date;
  type: 'task:updated'; // For compatibility
}

interface TaskDeletedData {
  taskId: string;
  task?: Task;
  context: TaskContext;
  timestamp: Date;
  type: 'task:deleted'; // For compatibility
}

interface TaskNoteAddedData {
  taskId: string;
  task: Task;
  context: TaskContext;
  timestamp: Date;
  type: 'task:note_added'; // For compatibility
}

// Agent lifecycle event data
interface AgentSpawnedData {
  type: 'agent:spawned'; // For compatibility with existing handlers
  taskId?: string;
  agentThreadId: ThreadId;
  provider: string;
  model: string;
  context: {
    actor: string;
    isHuman: boolean;
  };
  timestamp: Date;
}

export interface AgentSummaryUpdatedData {
  summary: string;
  agentThreadId: ThreadId;
  timestamp: Date;
}

// Project event data types
interface ProjectCreatedData {
  projectId: string;
  project: {
    id: string;
    name: string;
    description?: string;
    path: string;
  };
  context: {
    actor: string;
    isHuman: boolean;
  };
  timestamp: Date;
  type: 'project:created'; // For compatibility
}

interface ProjectUpdatedData {
  projectId: string;
  project: {
    id: string;
    name: string;
    description?: string;
    path: string;
  };
  context: {
    actor: string;
    isHuman: boolean;
  };
  timestamp: Date;
  type: 'project:updated'; // For compatibility
}

interface ProjectDeletedData {
  projectId: string;
  project: {
    id: string;
    name: string;
    description?: string;
    path: string;
  };
  context: {
    actor: string;
    isHuman: boolean;
  };
  timestamp: Date;
  type: 'project:deleted'; // For compatibility
}

// System event data
interface SystemNotificationData {
  message: string;
  severity: 'info' | 'warning' | 'error';
  context: {
    actor: string;
    isHuman: boolean;
  };
  timestamp: Date;
  type: 'system:notification'; // For compatibility
}

// Error type definitions - centralized for reuse
export type ErrorType =
  | 'provider_failure'
  | 'tool_execution'
  | 'processing_error'
  | 'timeout'
  | 'streaming_error';
export type ErrorPhase =
  | 'provider_response'
  | 'tool_execution'
  | 'conversation_processing'
  | 'initialization';

// Runtime type guards
export function isErrorType(value: unknown): value is ErrorType {
  return (
    typeof value === 'string' &&
    [
      'provider_failure',
      'tool_execution',
      'processing_error',
      'timeout',
      'streaming_error',
    ].includes(value)
  );
}

export function isErrorPhase(value: unknown): value is ErrorPhase {
  return (
    typeof value === 'string' &&
    ['provider_response', 'tool_execution', 'conversation_processing', 'initialization'].includes(
      value
    )
  );
}

// Agent error data
export interface AgentErrorData {
  errorType: ErrorType;
  message: string;
  stack?: string;
  context: {
    phase: ErrorPhase;
    // Available from Agent
    providerName?: string; // From this.providerInstance?.providerName
    providerInstanceId?: string; // From thread metadata
    modelId?: string; // From thread metadata
    // For tool-related errors
    toolName?: string; // When phase === 'tool_execution'
    toolCallId?: string; // When phase === 'tool_execution'
    // Additional context
    workingDirectory?: string;
    retryAttempt?: number;
  };
  isRetryable: boolean;
  retryCount?: number;
}

// Discriminated union for type-safe event handling
export type LaceEvent =
  | (BaseLaceEvent & {
      type: 'USER_MESSAGE';
      data: string;
    })
  | (BaseLaceEvent & {
      type: 'AGENT_MESSAGE';
      data: AgentMessageData;
    })
  | (BaseLaceEvent & {
      type: 'TOOL_CALL';
      data: ToolCall;
    })
  | (BaseLaceEvent & {
      type: 'TOOL_RESULT';
      data: ToolResult;
    })
  | (BaseLaceEvent & {
      type: 'TOOL_APPROVAL_REQUEST';
      data: ToolApprovalRequestData;
    })
  | (BaseLaceEvent & {
      type: 'TOOL_APPROVAL_RESPONSE';
      data: ToolApprovalResponseData;
    })
  | (BaseLaceEvent & {
      type: 'LOCAL_SYSTEM_MESSAGE';
      data: string;
    })
  | (BaseLaceEvent & {
      type: 'SYSTEM_PROMPT';
      data: string;
    })
  | (BaseLaceEvent & {
      type: 'USER_SYSTEM_PROMPT';
      data: string;
    })
  | (BaseLaceEvent & {
      type: 'COMPACTION';
      data: CompactionData;
    })
  | (BaseLaceEvent & {
      type: 'AGENT_TOKEN';
      data: AgentTokenData;
    })
  | (BaseLaceEvent & {
      type: 'AGENT_STREAMING';
      data: AgentStreamingData;
    })
  | (BaseLaceEvent & {
      type: 'AGENT_STATE_CHANGE';
      data: AgentStateChangeData;
    })
  | (BaseLaceEvent & {
      type: 'COMPACTION_START';
      data: CompactionStartData;
    })
  | (BaseLaceEvent & {
      type: 'COMPACTION_COMPLETE';
      data: CompactionCompleteData;
    })
  | (BaseLaceEvent & {
      type: 'TASK_CREATED';
      data: TaskCreatedData;
    })
  | (BaseLaceEvent & {
      type: 'TASK_UPDATED';
      data: TaskUpdatedData;
    })
  | (BaseLaceEvent & {
      type: 'TASK_DELETED';
      data: TaskDeletedData;
    })
  | (BaseLaceEvent & {
      type: 'TASK_NOTE_ADDED';
      data: TaskNoteAddedData;
    })
  | (BaseLaceEvent & {
      type: 'AGENT_SPAWNED';
      data: AgentSpawnedData;
    })
  | (BaseLaceEvent & {
      type: 'AGENT_SUMMARY_UPDATED';
      data: AgentSummaryUpdatedData;
    })
  | (BaseLaceEvent & {
      type: 'PROJECT_CREATED';
      data: ProjectCreatedData;
    })
  | (BaseLaceEvent & {
      type: 'PROJECT_UPDATED';
      data: ProjectUpdatedData;
    })
  | (BaseLaceEvent & {
      type: 'PROJECT_DELETED';
      data: ProjectDeletedData;
    })
  | (BaseLaceEvent & {
      type: 'SYSTEM_NOTIFICATION';
      data: SystemNotificationData;
    })
  | (BaseLaceEvent & {
      type: 'AGENT_ERROR';
      data: AgentErrorData;
    });

export interface Thread {
  id: string;
  sessionId?: string;
  projectId?: string;
  createdAt: Date;
  updatedAt: Date;
  events: LaceEvent[];
  metadata?: {
    name?: string;
    isSession?: boolean;
    provider?: string;
    model?: string;
    [key: string]: unknown;
  };
}

// Branded type for thread IDs
export type ThreadId = string & { readonly __brand: 'ThreadId' };

// Type guard
export function isThreadId(value: string): value is ThreadId {
  return /^lace_\d{8}_[a-z0-9]{6}(\.\d+)*$/.test(value);
}

// Constructor with validation
export function asThreadId(value: string): ThreadId {
  if (!isThreadId(value)) {
    throw new Error(`Invalid thread ID format: ${value}`);
  }
  return value;
}

// For new agent specifications
export type NewAgentSpec = string & { readonly __brand: 'NewAgentSpec' };

export function isNewAgentSpec(value: string): value is NewAgentSpec {
  return /^new:([^/]+)\/(.+)$/.test(value);
}

export function createNewAgentSpec(provider: string, model: string): NewAgentSpec {
  return `new:${provider}/${model}` as NewAgentSpec;
}

// Unsafe cast for internal use only (e.g., when we know format is correct)
export function asNewAgentSpec(value: string): NewAgentSpec {
  return value as NewAgentSpec;
}

// Union type for task assignment
export type AssigneeId = ThreadId | NewAgentSpec | 'human';

export function isAssigneeId(value: string): value is AssigneeId {
  return isThreadId(value) || isNewAgentSpec(value) || value === 'human';
}

// Unsafe cast for internal use only (e.g., when we know format is correct)
export function asAssigneeId(value: string): AssigneeId {
  return value as AssigneeId;
}
