// ABOUTME: Build script that creates simple single-file Lace executable
// ABOUTME: Embeds Next.js standalone build as ZIP and creates Bun executable

import { execSync } from 'child_process';
import { readFileSync, writeFileSync, existsSync, mkdirSync, cpSync, statSync } from 'fs';
import { join, resolve, dirname, basename } from 'path';

interface BuildOptions {
  target?: string;
  name?: string;
  outdir?: string;
  sign?: boolean;
  bundle?: boolean;
}

interface NFTTraceData {
  timestamp: string;
  serverFile: string;
  tracedFiles: string[];
  summary: {
    totalFiles: number;
    nodeModulesFiles: number;
    hasIsDocker: boolean;
    hasOpen: boolean;
  };
}

/**
 * Loads and parses the NFT trace file generated by trace-server-dependencies.mjs
 */
function loadNFTTrace(traceFilePath: string): NFTTraceData | null {
  try {
    if (!existsSync(traceFilePath)) {
      console.warn(`‚ö†Ô∏è  NFT trace file not found at ${traceFilePath}`);
      return null;
    }

    const traceContent = readFileSync(traceFilePath, 'utf8');
    const traceData: NFTTraceData = JSON.parse(traceContent);

    console.log(`üìã Loaded NFT trace from ${traceFilePath}`);
    console.log(`   Traced files: ${traceData.tracedFiles.length}`);
    console.log(
      `   Has required packages: ${traceData.summary.hasIsDocker && traceData.summary.hasOpen ? '‚úÖ' : '‚ùå'}`
    );

    return traceData;
  } catch (error) {
    console.warn(`‚ö†Ô∏è  Failed to load NFT trace: ${error}`);
    return null;
  }
}

/**
 * Copies only the dependencies specified in the NFT trace instead of entire node_modules
 */
async function copyTracedDependencies(
  sourceNodeModules: string,
  targetNodeModules: string,
  tracedFiles: string[]
): Promise<void> {
  console.log('üì¶ Copying traced dependencies...');

  // Ensure target directory exists
  mkdirSync(targetNodeModules, { recursive: true });

  // Extract unique package patterns from traced files
  const packagePatterns = new Set<string>();
  for (const pattern of tracedFiles) {
    if (pattern.includes('node_modules/')) {
      // Extract package root from any path: handle scoped packages (@scope/name) and regular packages
      const match = pattern.match(/^(.+?node_modules\/(@[^\/]+\/[^\/]+|[^\/]+))(?:\/|$)/);
      if (match) {
        packagePatterns.add(match[1]);
      }
    }
  }

  console.log(`   Found ${packagePatterns.size} unique package patterns`);

  let copiedPackages = 0;

  for (const pattern of packagePatterns) {
    const packageName = pattern.replace('node_modules/', '');
    const sourcePath = join(sourceNodeModules, packageName);
    const targetPath = join(targetNodeModules, packageName);

    try {
      if (existsSync(sourcePath)) {
        // Copy the package directory, dereferencing symlinks
        cpSync(sourcePath, targetPath, {
          recursive: true,
          preserveTimestamps: true,
          dereference: true,
          filter: (src) => {
            // Skip unnecessary files to reduce size
            const name = basename(src);
            return !name.startsWith('.') || name === '.js' || name === '.json';
          },
        });

        copiedPackages++;

        console.log(`   ‚úÖ Copied: ${packageName}`);
      } else {
        console.warn(`   ‚ö†Ô∏è  Package not found: ${packageName} at ${sourcePath}`);
      }
    } catch (error) {
      console.error(`   ‚ùå Failed to copy ${packageName}: ${error}`);
    }
  }

  console.log(`üì¶ Dependency copying complete:`);
  console.log(`   Packages copied: ${copiedPackages}/${packagePatterns.size}`);
}

/**
 * Alternative approach: Build core packages and use package manager to install prod dependencies
 */
async function copyProductionDependencies(targetNodeModules: string): Promise<void> {
  console.log('üì¶ Installing production dependencies only...');

  const tempDir = 'build/temp-deps';
  try {
    // Create temp directory for production install
    execSync(`rm -rf ${tempDir}`, { stdio: 'pipe' });
    mkdirSync(tempDir, { recursive: true });

    // Copy package.json files
    execSync(`cp package.json ${tempDir}/`, { stdio: 'pipe' });
    if (existsSync('package-lock.json')) {
      execSync(`cp package-lock.json ${tempDir}/`, { stdio: 'pipe' });
    }

    // Install only production dependencies
    console.log('   Running npm ci --omit=dev...');
    execSync('npm ci --omit=dev', {
      cwd: tempDir,
      stdio: 'pipe',
    });

    // Copy the pruned node_modules
    const tempNodeModules = join(tempDir, 'node_modules');
    if (existsSync(tempNodeModules)) {
      cpSync(tempNodeModules, targetNodeModules, { recursive: true });
      console.log('   ‚úÖ Production dependencies installed');

      // Get size
      const stats = statSync(targetNodeModules);
      console.log(`   üì¶ Size: ${(stats.size / 1024 / 1024).toFixed(1)}MB (estimated)`);
    }
  } catch (error) {
    console.error(`   ‚ùå Failed to install production dependencies: ${error}`);
    throw error;
  } finally {
    // Cleanup
    execSync(`rm -rf ${tempDir}`, { stdio: 'pipe' });
  }
}

function parseArgs(): BuildOptions {
  const args = process.argv.slice(2);
  const options: BuildOptions = {};

  for (let i = 0; i < args.length; i++) {
    switch (args[i]) {
      case '--target':
        options.target = args[++i];
        break;
      case '--name':
        options.name = args[++i];
        break;
      case '--outdir':
        options.outdir = args[++i];
        break;
      case '--sign':
        options.sign = true;
        break;
      case '--bundle':
        options.bundle = true;
        break;
      case '--help':
        console.log(`
Usage: npx tsx build-simple.ts [options]

Options:
  --target <target>    Bun target (default: bun-darwin-arm64)
  --name <name>        Output executable name (default: lace-standalone)  
  --outdir <outdir>    Output directory (default: build)
  --sign               Sign and notarize the binary (macOS only)
  --bundle             Create macOS .app bundle (macOS only)
  --help               Show this help

Environment Variables:
  BUILD_PROD_DEPS=true     Use production dependencies only (smaller, slower)
  
Dependency Selection (in order of preference):
  1. NFT trace file (packages/web/server-dependencies.json) - fastest, smallest
  2. BUILD_PROD_DEPS=true - production only via npm ci --omit=dev
  3. Fallback: entire node_modules directory

Examples:
  npx tsx build-simple.ts
  npx tsx build-simple.ts --target bun-linux-x64 --name lace-linux
  BUILD_PROD_DEPS=true npx tsx build-simple.ts
  npx tsx build-simple.ts --sign
  npx tsx build-simple.ts --bundle --sign
`);
        process.exit(0);
    }
  }

  return options;
}

async function createAppBundle(
  executablePath: string,
  baseName: string,
  outdir: string
): Promise<string> {
  const appName = 'Lace';
  const appBundlePath = join(outdir, `${appName}.app`);
  const contentsPath = join(appBundlePath, 'Contents');
  const macosPath = join(contentsPath, 'MacOS');
  const resourcesPath = join(contentsPath, 'Resources');

  // Create app bundle structure
  mkdirSync(appBundlePath, { recursive: true });
  mkdirSync(contentsPath, { recursive: true });
  mkdirSync(macosPath, { recursive: true });
  mkdirSync(resourcesPath, { recursive: true });

  // Build the Swift menu bar app
  console.log('üì± Building Swift menu bar app...');
  execSync('make clean && make build', {
    cwd: 'platforms/macos',
    stdio: 'inherit',
  });

  // Copy the Swift app executable
  const swiftAppPath = 'platforms/macos/build/Lace.app/Contents/MacOS/Lace';
  if (!existsSync(swiftAppPath)) {
    throw new Error(
      `Swift app not found at ${swiftAppPath}. Make sure Swift compilation succeeded.`
    );
  }
  execSync(`cp "${swiftAppPath}" "${join(macosPath, appName)}"`);

  // Copy the lace server as 'lace-server'
  execSync(`cp "${executablePath}" "${join(macosPath, 'lace-server')}"`);

  // Copy Info.plist
  execSync(`cp platforms/macos/Info.plist "${contentsPath}/"`);

  // Copy app icon
  if (existsSync('platforms/macos/AppIcon.icns')) {
    execSync(`cp platforms/macos/AppIcon.icns "${resourcesPath}/"`);
    console.log(`   üé® App icon copied`);
  }

  console.log(`   üì± Swift menu bar app: ${appName}`);
  console.log(`   üñ•Ô∏è  Server binary: lace-server`);
  console.log(`   üìÑ Info.plist copied`);

  return resolve(appBundlePath);
}

async function buildSimpleExecutable(options: BuildOptions = {}) {
  const target = options.target || 'bun-darwin-arm64';
  const name = options.name || 'lace-standalone';
  const outdir = options.outdir || 'build';
  const sign = options.sign || false;
  const bundle = options.bundle || false;

  console.log('üî® Building simple single-file executable...');
  console.log(`   üéØ Target: ${target}`);
  console.log(`   üìù Name: ${name}`);
  console.log(`   üìÅ Output: ${outdir}\n`);

  // Step 1: Check Next.js build exists
  console.log('1Ô∏è‚É£ Checking Next.js build...');
  const nextBuildPath = 'packages/web/.next';
  if (!existsSync(nextBuildPath)) {
    throw new Error(
      `Next.js build not found at ${nextBuildPath}. Run: cd packages/web && bun run build`
    );
  }

  // Check that standalone build exists
  const standalonePath = 'packages/web/.next/standalone';
  if (!existsSync(standalonePath)) {
    throw new Error(
      `Standalone build not found at ${standalonePath}. Ensure next.config.ts has output: 'standalone'`
    );
  }
  console.log('‚úÖ Next.js standalone build found\n');

  // Step 1.5: Copy custom server (no compilation - let Bun run the TypeScript directly)
  console.log('1Ô∏è‚É£.5Ô∏è‚É£ Using custom server TypeScript file...');

  if (!existsSync('packages/web/server-custom.ts')) {
    throw new Error('Custom server-custom.ts not found');
  }
  console.log('‚úÖ Custom server ready\n');

  // Step 2: Create ZIP of standalone build + custom server
  console.log('2Ô∏è‚É£ Creating ZIP of standalone build...');
  const zipPath = 'build/lace-standalone.zip';
  mkdirSync('build', { recursive: true });

  // Create temp directory to organize files for ZIP
  const tempBuildDir = 'build/temp-standalone';
  execSync(`rm -rf ${tempBuildDir}`, { stdio: 'pipe' });
  mkdirSync(tempBuildDir, { recursive: true });

  // Copy standalone build
  execSync(`cp -r packages/web/.next/standalone ${tempBuildDir}/standalone`, {
    stdio: 'pipe',
  });

  // Copy core package source directory to match alias ~/ -> packages/core/src
  execSync(
    `mkdir -p ${tempBuildDir}/standalone/packages/core && cp -r packages/core/src ${tempBuildDir}/standalone/packages/core/src`,
    {
      stdio: 'pipe',
    }
  );
  console.log('üìÅ Core source directory copied to standalone/packages/core/src/');

  // Copy dependencies using the most efficient method available
  // This significantly reduces the artifact size by only including required packages
  console.log('üì¶ Copying dependencies...');

  const useProductionOnly = process.env.BUILD_PROD_DEPS === 'true';
  const nftTrace = loadNFTTrace('packages/web/server-dependencies.json');

  if (useProductionOnly) {
    console.log('   Using production-only dependencies (BUILD_PROD_DEPS=true)');
    await copyProductionDependencies(`${tempBuildDir}/standalone/node_modules`);
  } else if (nftTrace && nftTrace.tracedFiles.length > 0) {
    console.log('   Using NFT traced dependencies');
    await copyTracedDependencies(
      'node_modules',
      `${tempBuildDir}/standalone/node_modules`,
      nftTrace.tracedFiles
    );
  } else {
    console.warn('‚ö†Ô∏è  NFT trace not available, falling back to copying entire node_modules...');
    console.warn('   Consider running: bun ./scripts/trace-server-dependencies.mjs');
    console.warn('   Or set BUILD_PROD_DEPS=true to use production dependencies only');
    console.log('üì¶ Fallback: Copying workspace dependencies...');

    // Try rsync first (preserves symlinks and metadata), fallback to cp -a
    try {
      execSync(`rsync -a --delete node_modules/ ${tempBuildDir}/standalone/node_modules/`, {
        stdio: 'pipe',
      });
    } catch {
      // Fallback to cp -a if rsync is unavailable
      execSync(`cp -a node_modules ${tempBuildDir}/standalone/`, {
        stdio: 'pipe',
      });
    }
    console.log('üìÅ Workspace node_modules copied to standalone/');
  }

  // Copy static files to the correct location where Next.js server expects them
  // The server runs from packages/web, so static files must be at packages/web/.next/static
  if (existsSync('packages/web/.next/static')) {
    mkdirSync(`${tempBuildDir}/standalone/packages/web/.next`, { recursive: true });
    execSync(
      `cp -r packages/web/.next/static ${tempBuildDir}/standalone/packages/web/.next/static`,
      {
        stdio: 'pipe',
      }
    );
    console.log('üìÅ Static assets copied to packages/web/.next/static/');
  } else {
    console.warn('‚ö†Ô∏è  Warning: No .next/static directory found - static assets may be missing');
  }

  // Replace the standalone server with our custom enhanced server (TypeScript)
  // First remove the original server.js from packages/web
  execSync(`rm -f ${tempBuildDir}/standalone/packages/web/server.js`, {
    stdio: 'pipe',
  });
  // Then copy our TypeScript server to the packages/web directory where Next.js dependencies are
  execSync(`cp packages/web/server-custom.ts ${tempBuildDir}/standalone/packages/web/server.ts`, {
    stdio: 'pipe',
  });

  // Create ZIP with just the standalone build + our server
  execSync(`cd ${tempBuildDir} && zip -r ../lace-standalone.zip . -q`, {
    stdio: 'pipe',
  });

  // Clean up temp directory
  execSync(`rm -rf ${tempBuildDir}`, { stdio: 'pipe' });

  // The standalone directory already contains its own .next with build files,
  // but we need to ensure static assets are properly linked
  console.log('üì¶ Verifying ZIP contents...');
  execSync(`unzip -l ${zipPath} | head -20`, { stdio: 'inherit' });

  const zipStats = execSync(`wc -c ${zipPath}`, { encoding: 'utf8' });
  const zipSize = parseInt(zipStats.split(' ')[0]);
  console.log(`‚úÖ Standalone ZIP created: ${(zipSize / 1024 / 1024).toFixed(1)}MB\n`);

  // Step 3: Create executable that imports ZIP directly
  console.log('3Ô∏è‚É£ Creating executable with bundled ZIP...');

  // Use the simple-bundle.ts directly - Bun will bundle the ZIP file
  const execSourcePath = 'scripts/simple-bundle.ts';
  console.log('‚úÖ Executable source ready\n');

  // Step 4: Compile with Bun
  console.log('4Ô∏è‚É£ Compiling with Bun...');
  mkdirSync(outdir, { recursive: true });
  const outputPath = join(outdir, name);

  const compileCmd = `bun build ${execSourcePath} --compile --outfile=${outputPath} --target=${target} --minify --sourcemap=none`;
  console.log(`üîß Running: ${compileCmd}`);

  execSync(compileCmd, { stdio: 'inherit' });

  // Handle code signing
  if (sign && process.platform === 'darwin') {
    console.log('üîè Starting signing and notarization...');
    try {
      execSync(`npx tsx scripts/sign-and-notarize.ts --binary "${outputPath}"`, {
        stdio: 'inherit',
      });
    } catch (error) {
      console.error('‚ùå Signing failed:', error);
      throw error;
    }
  } else if (process.platform === 'darwin') {
    console.log('üîè Applying basic ad-hoc signing (macOS)...');
    try {
      execSync(`codesign --remove-signature "${outputPath}"`, { stdio: 'pipe' });
      execSync(`codesign -s - --deep --force "${outputPath}"`, { stdio: 'pipe' });
      console.log('‚úÖ Ad-hoc signing completed');
    } catch (error) {
      console.warn('‚ö†Ô∏è  Warning: Ad-hoc signing failed, but executable may still work');
    }
  } else {
    console.log('‚ÑπÔ∏è  Skipping code signing (non-macOS platform)');
  }

  // Check file size
  const execStats = execSync(`wc -c ${outputPath}`, { encoding: 'utf8' });
  const execSize = parseInt(execStats.split(' ')[0]);
  console.log(`‚úÖ Executable created: ${(execSize / 1024 / 1024).toFixed(1)}MB\n`);

  // Step 5: Validate executable exists
  console.log('5Ô∏è‚É£ Validating executable...');
  if (existsSync(outputPath)) {
    console.log('‚úÖ Executable created successfully');
    console.log('‚ÑπÔ∏è  Note: Cross-platform testing skipped (may not be compatible with build host)');
  } else {
    throw new Error('Executable was not created');
  }

  // Step 6: Create app bundle if requested
  let appBundlePath = '';
  if (bundle && process.platform === 'darwin') {
    console.log('6Ô∏è‚É£ Creating macOS app bundle...');
    appBundlePath = await createAppBundle(outputPath, name, outdir);
    console.log(`‚úÖ App bundle created: ${appBundlePath}`);
  }

  // Summary
  console.log('üìä Build Summary:');
  console.log(`   üì¶ ZIP Size: ${(zipSize / 1024 / 1024).toFixed(1)}MB`);
  console.log(`   üíæ Executable: ${(execSize / 1024 / 1024).toFixed(1)}MB`);
  console.log(`   üìÅ Location: ${resolve(outputPath)}`);
  console.log('\nüéâ Simple single-file executable ready!');
  console.log(`\nTo run: ./${outputPath}`);
}

if (import.meta.url === `file://${process.argv[1]}`) {
  const options = parseArgs();
  buildSimpleExecutable(options).catch((error) => {
    console.error('‚ùå Build failed:', error);
    process.exit(1);
  });
}
