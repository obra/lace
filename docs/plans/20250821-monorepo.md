# Monorepo Restructuring Plan

## Problem

Lace started as a simple CLI app, then added a web interface as a package, then removed the CLI leaving the backend at the top level. This created a weird half-monorepo setup with:

- Backend at root level (`src/`)
- Web package in `packages/web/` 
- Mixed dependency management and build scripts

## Goal

Convert to a proper multi-package monorepo:

```
packages/
├── core/          # Backend logic (@lace/core)
└── web/           # Next.js app (lace-web)
```

## Lessons Learned from Failed Attempt

**What went wrong:**
1. Used shell `mv` instead of `git mv` - broke file history tracking
2. Moved everything at once instead of incremental approach
3. Missed hardcoded `src/` path assumptions in `resource-resolver.ts` and other files
4. Complex conflict resolution during rebase introduced subtle bugs
5. Runtime failures that only appeared in production builds

**Key insight:** There are hardcoded path assumptions throughout the codebase that only surface during runtime or complex operations.

## The Right Way: Incremental Clean Extraction

### Phase 1: Preparation (on main branch)

1. **Audit hardcoded paths first**
   ```bash
   # Find all hardcoded src/ references
   grep -r "src/" . --include="*.ts" --include="*.js" --include="*.json"
   grep -r '~/.*/' . --include="*.ts" 
   grep -r 'import.*src' . --include="*.ts"
   ```

2. **Create baseline test results**
   ```bash
   npm test 2>&1 | tee baseline-tests.txt
   cd packages/web && npm test 2>&1 | tee baseline-web-tests.txt
   ```

3. **Test all build commands work**
   ```bash
   npm run build
   npm run build:standalone:clean  
   npm run lint
   npm run typecheck
   ```

### Phase 2: Create Core Package Structure

1. **Create new branch from main**
   ```bash
   git checkout main
   git pull origin main
   git checkout -b monorepo-clean-extraction
   ```

2. **Create packages directory structure**
   ```bash
   mkdir -p packages/core
   ```

3. **Use proper git moves to preserve history**
   ```bash
   # Move source files with git to preserve history
   git mv src packages/core/src
   
   # Move related files
   git mv vitest.config.ts packages/core/
   git mv tsconfig.json packages/core/  # Will create new root tsconfig later
   
   # Commit the move to establish file history
   git commit -m "move: relocate src/ to packages/core/src/ with preserved history"
   ```

4. **Test after move**
   ```bash
   # Should fail but show what needs fixing
   cd packages/core && npm test
   ```

### Phase 3: Fix Hardcoded Paths Systematically

1. **Update resource-resolver.ts first** (most critical)
   ```typescript
   // Change from:
   const srcIndex = moduleDir.indexOf('/src/');
   // To:
   const srcIndex = moduleDir.indexOf('/packages/core/src/') !== -1 ? 
     moduleDir.indexOf('/packages/core/src/') + '/packages/core'.length :
     moduleDir.indexOf('/src/');
   ```

2. **Update all build scripts that reference src/**
   ```bash
   # Find all scripts that reference src/
   grep -r "src/" scripts/ package.json
   ```

3. **Test after each path fix**
   ```bash
   cd packages/core && npm test
   ```

### Phase 4: Create Core Package Configuration

1. **Create packages/core/package.json**
   - Move dependencies from root to core
   - Create proper exports map
   - Set up build scripts

2. **Create packages/core/tsconfig.json**
   - Configure for composite builds
   - Set up path aliases

3. **Create packages/core/eslint.config.js**

4. **Test core package isolation**
   ```bash
   cd packages/core
   npm install
   npm run build  
   npm test
   ```

### Phase 5: Update Web Package Incrementally

1. **Add @lace/core dependency to web package**
   ```bash
   cd packages/web
   npm install file:../core
   ```

2. **Update facade files to use @lace/core** 
   - `lib/server/lace-imports.ts`
   - `types/core.ts`

3. **Fix import violations one by one**
   ```bash
   # Find all ~/ imports in web package
   grep -r "from.*~/" packages/web --include="*.ts" --include="*.tsx"
   
   # Fix each file individually and test
   # Use facades, not direct @lace/core imports
   ```

4. **Test web package after each fix**
   ```bash
   cd packages/web && npm test
   ```

### Phase 6: Update Root Configuration

1. **Create workspace root package.json**
   - Add workspaces configuration
   - Remove core dependencies
   - Update scripts to use workspace commands

2. **Create root tsconfig.json with project references**

3. **Test full workspace**
   ```bash
   npm run build
   npm run test  
   npm run typecheck
   npm run lint
   ```

### Phase 7: Critical Testing

1. **Test all build scenarios**
   ```bash
   npm run build:standalone:clean
   npm run build:macos
   npm run dev
   ```

2. **Test rebase scenarios**
   ```bash
   # Make a test change to main
   git checkout main
   echo "// test change" >> src/agents/agent.ts
   git add -A && git commit -m "test: change for rebase test"
   
   # Rebase extraction branch
   git checkout monorepo-clean-extraction  
   git rebase main
   
   # Verify change was applied to packages/core/src/agents/agent.ts
   ```

## Key Principles

1. **Use git mv for all file moves** - Preserves history for clean rebases
2. **Test after every change** - Don't accumulate broken state
3. **Fix hardcoded paths before moving files** - Prevents runtime failures
4. **Move incrementally** - One module/concern at a time
5. **Maintain 100% test pass rate** - Never commit broken tests
6. **Use facades properly** - Web package should only import through controlled interfaces

## Anti-Patterns to Avoid

❌ **Shell moves**: `mv src packages/core` breaks git history  
❌ **Batch moves**: Moving everything at once hides individual issues  
❌ **Ignoring runtime paths**: Hardcoded paths cause production failures  
❌ **Complex conflict resolution**: Too many changes make conflicts hard to resolve  
❌ **Direct core imports**: Web package should use facades, not `@lace/core` directly  

## Success Criteria

- ✅ 100% test pass rate maintained throughout
- ✅ All build commands work (dev, production, standalone)  
- ✅ Clean rebase on main with proper file history
- ✅ Runtime works without path resolution errors
- ✅ Proper facade pattern maintained in web package
- ✅ Each package has clear boundaries and dependencies

## Files That Need Special Attention

- `utils/resource-resolver.ts` - Has hardcoded `src/` path logic
- `scripts/build-simple.ts` - References `src/` for copying
- `scripts/trace-server-dependencies.mjs` - NFT dependency tracing  
- Any file that uses `import.meta.url` for path resolution
- All build scripts in package.json
- TypeScript path mapping configurations

## Validation Steps

After each major change:

1. Run tests: `npm test`
2. Build packages: `npm run build`
3. Type check: `npm run typecheck`  
4. Lint: `npm run lint`
5. Test imports: Try importing from facades in web package
6. Test runtime: Start dev server and verify functionality

The incremental approach with proper git moves and constant testing is the only reliable way to do this refactor safely.