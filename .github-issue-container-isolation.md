# Container Isolation vs. Git Integration Trade-offs

## Summary

The current worktree-based container implementation provides excellent git integration (commits appear immediately as branches in the main repo) but **compromises container isolation**. This document explores the trade-offs and proposes solutions for true isolation.

## The Problem

### Current Implementation (Worktree + Dual Mount)

```
Container:
/workspace/          → Working directory (mounted from host)
/workspace/.git-main/ → Main .git directory (mounted R/W from host)

Environment:
GIT_DIR=/workspace/.git-main/worktrees/session_xxx
GIT_WORK_TREE=/workspace
```

**Benefits:**
- ✅ Commits in container appear immediately as `lace/session/xxx` branch in main repo
- ✅ Standard git workflow - can merge anytime
- ✅ No sync step needed
- ✅ Space efficient (shared git objects)

**Security Issues:**
- ❌ Container has FULL access to git database
- ❌ Can delete/corrupt ANY branch (not just session branch)
- ❌ Can force-push to remotes
- ❌ Can modify git hooks
- ❌ Can rewrite history
- ❌ **Violates isolation promise**

### Example Attack Vectors

Even with "good intentions", bugs or malicious code could:

```bash
# In container
git checkout main
git reset --hard HEAD~100    # Destroy 100 commits
git push origin --delete main  # Delete remote branch
git branch -D $(git branch | grep -v "*")  # Delete all branches
git config core.hooksPath /malicious  # Hijack hooks
```

## Why Any Git Connection Breaks Isolation

We explored several approaches:

### 1. **Clones with Remotes**
```bash
git clone --local /host/project /clones/session
git remote add origin /host/project
```
- Can still `git push origin +main:main` (force push to main)
- Any remote access = potential corruption

### 2. **Worktrees**
- By definition, worktrees share `.git` with main repo
- Must have write access for commits
- Write access = can modify anything

### 3. **Detached/Isolated Clones** (Previous Implementation)
```bash
git clone --local /host/project /clones/session
# No remotes configured
```
- ✅ True isolation
- ❌ No easy merge-back
- ❌ Requires manual sync step

## The Fundamental Tension

**You cannot have both:**
1. **True isolation** - Container can't harm main repo
2. **Immediate git integration** - Commits visible in main repo

These are mutually exclusive goals.

## User Expectations

When users enable "container mode", they likely expect:
- ✅ "AI-generated code runs safely"
- ✅ "Can't damage my project"
- ✅ "Isolated until I decide to merge"

Current worktree implementation violates these expectations.

## Proposed Solutions

### Option A: Make Isolation Mode Configurable

```typescript
workspaceMode: 'local' | 'container-connected' | 'container-isolated'
```

**`container-connected`** (current):
- Worktree + dual mount
- Immediate branch visibility
- ⚠️ No isolation
- Best for: Trusted environments, personal projects

**`container-isolated`** (to implement):
- Detached clone (no remotes)
- UI button: "Push to Branch"
- User-initiated sync
- Best for: Running untrusted code, security-conscious users

**`local`**:
- No container
- Direct project access
- Best for: Development, debugging

### Option B: Read-Only Git Mount + Commit Export

Mount `.git` as **read-only**, but allow commits:

```bash
# Container can commit to worktree
git commit -m "work"

# But can't push/modify main repo
# Commits stay in worktree until user explicitly syncs
```

Then provide UI action: "Sync Session to Branch" which:
1. Commits pending work in worktree
2. Pushes worktree branch to main repo
3. User reviews and merges

This gives:
- ✅ Container can't corrupt main repo (read-only mount)
- ✅ Commits preserved in worktree
- ⚠️ Not "immediate" but user-controlled

**Technical challenge**: Can git commit with read-only `.git`? Needs investigation.

### Option C: Commit Interception/Proxy

Wrap git commands in container to only allow safe operations:

```bash
# In container
git() {
  case "$1" in
    commit|add|status|diff|log) command git "$@" ;;  # Safe
    push|branch|reset|rebase)   echo "Operation not allowed" ;;  # Dangerous
    *) command git "$@" ;;
  esac
}
```

**Issues**:
- Can be bypassed (call `/usr/bin/git` directly)
- Complex to maintain
- False sense of security

## Recommendation

Implement **Option A** with both modes:

1. **Default to `container-isolated`** (safe)
2. Provide `container-connected` for users who understand the risks
3. Show clear warnings about isolation trade-offs
4. Document security implications

This gives users choice while maintaining security by default.

## Migration Path

1. ✅ **Current**: Implement `container-connected` (done)
2. **Next**: Implement `container-isolated` with sync UI
3. **Then**: Add mode selection to session creation
4. **Future**: Consider read-only mount experiments

## Discussion Questions

1. What's the priority: convenience or isolation?
2. Should we default to isolated or connected mode?
3. Is user-initiated sync acceptable UX?
4. Do we need multiple isolation levels?
5. Should this be per-session or global config?

## Related Work

- **GitHub Codespaces**: Full git access (trusted environment)
- **Docker/Podman**: Isolation via namespaces (no git assumptions)
- **Git worktrees**: Designed for local branches, not sandboxing

## References

- [Git Worktrees Documentation](https://git-scm.com/docs/git-worktree)
- [Container Security Best Practices](https://docs.docker.com/engine/security/)
- Git clone `--local` behavior and hardlinks